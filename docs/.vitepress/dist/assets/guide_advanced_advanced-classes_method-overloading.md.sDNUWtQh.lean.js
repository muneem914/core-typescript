import{_ as t,C as e,c as h,o as l,j as i,G as k,ag as p,a}from"./chunks/framework.DPDPlp3K.js";const u=JSON.parse('{"title":"Method Overloading","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"guide/advanced/advanced-classes/method-overloading.md","filePath":"guide/advanced/advanced-classes/method-overloading.md"}'),r={name:"guide/advanced/advanced-classes/method-overloading.md"};function d(E,s,o,g,y,F){const n=e("Badge");return l(),h("div",null,[s[0]||(s[0]=i("h1",{id:"method-overloading",tabindex:"-1"},[a("Method Overloading "),i("a",{class:"header-anchor",href:"#method-overloading","aria-label":'Permalink to "Method Overloading"'},"â€‹")],-1)),s[1]||(s[1]=i("p",null,[a("Method overloading lets a class have "),i("strong",null,"multiple methods with the same name"),a(" but different parameter types/numbers. TypeScript resolves which method to call based on the inputs.")],-1)),s[2]||(s[2]=i("p",null,"Method overloading allows you to define multiple method signatures for the same method name but with different parameter types or counts. In TypeScript, you achieve overloading by:",-1)),s[3]||(s[3]=i("ul",null,[i("li",null,"Declaring multiple method signatures (without implementations)."),i("li",null,"Providing one implementation that handles all the declared signatures.")],-1)),s[4]||(s[4]=i("p",null,"This approach allows for the creation of more adaptable interfaces, where functions can gracefully handle diverse inputs while maintaining strict type safety. By clearly documenting the different ways a method can be invoked, method overloading simplifies the API, making it more intuitive and user-friendly for developers.",-1)),k(n,{type:"danger",text:"Note:"}),s[5]||(s[5]=p("",25))])}const m=t(r,[["render",d]]);export{u as __pageData,m as default};
